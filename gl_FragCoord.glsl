#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

void main() {
  vec2 st = gl_FragCoord.xy / u_resolution;
  // vec2 st = vec2(0.5, 0.5); // 가운데 픽셀의 경우 위 공식에 따라 이 값이 들어가게 될거임.
  // vec2 st = vec2(1., 0.); // 우하단 픽셀의 경우 위 공식에 따라 이 값이 들어가게 될거임.
  gl_FragColor = vec4(st.x, st.y, 0.0, 1.0);
}

/*
  gl_FragCoord


  gl_FragColor 내장 변수에 특정 컬러값을 넣어줌으로써,
  각 픽셀에 색상을 지정해주도록 하는 게 프래그먼트 셰이더의 목적이었다.

  그렇다면, '어느 픽셀에 어떤 색상을 띄울 것인가'
  를 결정하고자 한다면,
  gl_FragColor는 '어떤 색상'은 결정할 수 있지만.
  '어느 픽셀에'에 해당하는 부분은 gl_FragColor 만으로는 해결하기 어려움.

  바로, 이 부분을 해결하기 위한 변수가 'gl_FragCoord'라고 보면 됨.
  여기서부터 GLSL 코드 특유의 세계관이 시작이 되는 부분!

  '우리가 쓰는 저 프래그먼트 셰이더 코드는,
  glslCanvas 화면에 존재하는 모든 픽셀에 동일하게 적용됨.'

  이 말이 굉장히 중요함.

  저 화면에 어느 픽셀이든 받게 되는 코드는
  우리가 작성한 프래그먼트 셰이더로 동일하다!

  그런데, 동일한 코드를 받으면서 어떻게 다른 색깔이 나오는걸까?
  상식적으로 생각하면, 같은 인풋에는 같은 아웃풋(색상)이 나와야 되는거 아닌가?
  같은 코드를 집어넣었는데, 어떻게 한 픽셀은 초록색을, 다른 픽셀은 빨강색을 띄워주는 걸까?

  그 차이를 불러일으키는 결정적인 차이점이 바로 'gl_FragCoord' 라고 보면 됨!

  gl_FragCoord는 해당 픽셀이 갖고있는 '좌표값'을 의미함!

  참고로, WebGL 책에서도 배웠지만,
  GLSL(WebGL의 viewport도 동일)
  캔버스의 좌하단을 (0, 0) 원점으로 해서
  가로는 양의 x축, 세로는 양의 y축을 의미함. 

  그렇기 때문에, 모든 픽셀은 같은 gl_FragCoord 라는 변수를 사용하지만,
  해당 픽셀이 화면에서 어느 위치에 있느냐에 따라
  gl_FragCoord 값이 달라지게 되고, 이로 인해 각 픽셀의 색상값이 달라지게 되는 것!

  그렇기 때문에 동일한 코드를 집어넣더라도 각 픽셀의 색깔이 달라지는 것!
*/

/*
  main() 함수 코드 분석
  
  
  vec2 st = gl_FragCoord.xy / u_resolution;
  gl_FragColor = vec4(st.x, st.y, 0.0, 1.0);


  1. gl_FragCoord.xy

  x, y에 해당하는 좌표정보를 담아내는 변수를 만든 것 같음.
  두 가지 float 좌표값을 갖고 있어야 하므로, vec2라는 데이터타입으로 선언함.

  해당 변수에 어떤 값을 대입해 주는걸까?
  가령, 현재 glslCanvas가 500 * 500 의 해상도를 갖는 캔버스라고 가정해보자.
  그리고 해당 캔버스의 정 가운데 픽셀이 프래그먼트 셰이더 코드를 인식하는 과정을 정리해보자.

  우선, gl_FragCoord.xy는
  전체 화면에서 가운데 픽셀의 x, y 좌표값을 가져오라는 건데,
  전체 화면이 500 * 500 이므로, gl_FragCoord.xy는 (250, 250)이 되겠지


  2. / u_resolution

  그리고 나서 이것을 나눠주는데, u_resolution 이라는 vec2 타입 유니폼 변수로 나눠주라고 했음.
  이거는 지난 예제에서도 설명했듯이,
  캔버스 화면이 갖고 있는 가로, 세로 해상도값이 지정된 vec2 데이터라고 했지?

  따라서, 저 공식은 (250, 250)의 vec2 데이터를, (500, 500)의 vec2 데이터로 나눠주라는 뜻임!
  그러니 화면 가운데에 있는 픽셀의 경우 vec2 st에는 vec2(250. / 500.0, 250.0 / 500.0) 이 값이 들어갈거임.
  최종적으로 계산하면 (0.5, 0.5)가 들어가겠지!


  만약, 화면의 우하단 픽셀이라면 어떨까?
  vec2(500., 0.) / vec2(500.0, 500.0) 이므로,
  vec2(1., 0.) 이 값이 st에 최종적으로 들어가게 되므로,
  해당 픽셀은 r값만 1. 인 빨간색으로 찍히게 되겠지!

  
  이처럼, 같은 코드가 인풋으로 동일하게 들어가더라도, 
  해당 픽셀이 어느 위치에 있느냐에 따라 다른 색상값을 아웃풋으로 찍어내는
  GLSL 코드만이 갖고있는 독특한 세계관임.
*/